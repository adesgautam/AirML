{"version":3,"sources":["../source/get number type.js"],"names":["get_number_type","is_of_type","sort_out_arguments","first_argument","second_argument","third_argument","input","metadata","Error","country","national_number","phone","country_metadata","countries","type","String","undefined"],"mappings":"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","file":"get number type.js","sourcesContent":["import parse, { is_viable_phone_number } from './parse'\n\nimport { matches_entirely } from './common'\n\nimport\n{\n\tget_national_number_pattern,\n\tget_type_fixed_line,\n\tget_type_mobile,\n\tget_type_toll_free,\n\tget_type_premium_rate,\n\tget_type_personal_number,\n\tget_type_voice_mail,\n\tget_type_uan,\n\tget_type_pager,\n\tget_type_voip,\n\tget_type_shared_cost\n}\nfrom './metadata'\n\n// Finds out national phone number type (fixed line, mobile, etc)\nexport default function get_number_type(first_argument, second_argument, third_argument)\n{\n\tconst { input, metadata } = sort_out_arguments(first_argument, second_argument, third_argument)\n\n\t// Sanity check\n\tif (!metadata)\n\t{\n\t\tthrow new Error('Metadata not passed')\n\t}\n\n\t// When no input was passed\n\tif (!input)\n\t{\n\t\treturn\n\t}\n\n\t// When `parse()` returned `{}`\n\t// meaning that the phone number is not a valid one.\n\tif (!input.country)\n\t{\n\t\treturn\n\t}\n\n\tconst national_number = input.phone\n\tconst country_metadata = metadata.countries[input.country]\n\n\t// The following is copy-pasted from the original function:\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n\n\t// Is this national number even valid for this country\n\tif (!is_of_type(national_number, get_national_number_pattern(country_metadata)))\n\t{\n\t\treturn // 'UNKNOWN'\n\t}\n\n\tif (is_of_type(national_number, get_type_premium_rate(country_metadata)))\n\t{\n\t\treturn 'PREMIUM_RATE'\n\t}\n\n\tif (is_of_type(national_number, get_type_toll_free(country_metadata)))\n\t{\n\t\treturn 'TOLL_FREE'\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_shared_cost(country_metadata)))\n\t{\n\t\treturn 'SHARED_COST'\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_voip(country_metadata)))\n\t{\n\t\treturn 'VOIP'\n\t}\n\n\tif (is_of_type(national_number, get_type_personal_number(country_metadata)))\n\t{\n\t\treturn 'PERSONAL_NUMBER'\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_pager(country_metadata)))\n\t{\n\t\treturn 'PAGER'\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_uan(country_metadata)))\n\t{\n\t\treturn 'UAN'\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_voice_mail(country_metadata)))\n\t{\n\t\treturn 'VOICEMAIL'\n\t}\n\n\t// Is it fixed line number\n\tif (is_of_type(national_number, get_type_fixed_line(country_metadata)))\n\t{\n\t\t// Because duplicate regular expressions are removed\n\t\t// to reduce metadata size, if there's no \"mobile\" pattern\n\t\t// then it means it was removed due to being a duplicate of some other pattern.\n\t\t//\n\t\tif (!get_type_mobile(country_metadata))\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\n\t\t// (no such country in the minimal metadata set)\n\t\t/* istanbul ignore if */\n\t\tif (is_of_type(national_number, get_type_mobile(country_metadata)))\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\treturn 'FIXED_LINE'\n\t}\n\n\tif (is_of_type(national_number, get_type_mobile(country_metadata)))\n\t{\n\t\treturn 'MOBILE'\n\t}\n\n\t// return 'UNKNOWN'\n}\n\nexport function is_of_type(national_number, type)\n{\n\t// // Check if any possible number lengths are present;\n\t// // if so, we use them to avoid checking\n\t// // the validation pattern if they don't match.\n\t// // If they are absent, this means they match\n\t// // the general description, which we have\n\t// // already checked before a specific number type.\n\t// if (get_possible_lengths(type) &&\n\t// \tget_possible_lengths(type).indexOf(national_number.length) === -1)\n\t// {\n\t// \treturn false\n\t// }\n\n\t// get_type_pattern(type) === type\n\treturn matches_entirely(national_number, type)\n}\n\n// Sort out arguments\nexport function sort_out_arguments(first_argument, second_argument, third_argument)\n{\n\tlet input\n\tlet metadata\n\n\t// Normalize numerical `value`.\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/142\n\tif (typeof first_argument === 'number')\n\t{\n\t\tfirst_argument = String(first_argument)\n\t}\n\n\tif (typeof first_argument === 'string')\n\t{\n\t\t// If country code is supplied\n\t\tif (typeof second_argument === 'string' || second_argument === undefined)\n\t\t{\n\t\t\tmetadata = third_argument\n\n\t\t\t// `parse` extracts phone numbers from raw text,\n\t\t\t// therefore it will cut off all \"garbage\" characters,\n\t\t\t// while this `validate` function needs to verify\n\t\t\t// that the phone number contains no \"garbage\"\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\n\t\t\tif (is_viable_phone_number(first_argument))\n\t\t\t{\n\t\t\t\tinput = parse(first_argument, second_argument, metadata)\n\t\t\t}\n\t\t}\n\t\t// Just an international phone number is supplied\n\t\telse\n\t\t{\n\t\t\tmetadata = second_argument\n\n\t\t\t// `parse` extracts phone numbers from raw text,\n\t\t\t// therefore it will cut off all \"garbage\" characters,\n\t\t\t// while this `validate` function needs to verify\n\t\t\t// that the phone number contains no \"garbage\"\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\n\t\t\tif (is_viable_phone_number(first_argument))\n\t\t\t{\n\t\t\t\tinput = parse(first_argument, metadata)\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// The `first_argument` must be a valid phone number\n\t\t// as a whole, not just a part of it which gets parsed here.\n\t\tif (first_argument && first_argument.phone && is_viable_phone_number(first_argument.phone))\n\t\t{\n\t\t\tinput = first_argument\n\t\t}\n\n\t\tmetadata = second_argument\n\t}\n\n\treturn { input, metadata }\n}"]}